// Generated by CoffeeScript 1.6.2
(function() {
  var Shavaluator, defaultConfig, luaCommands, uuid, _,
    __slice = [].slice;

  _ = require('underscore');

  uuid = require('uuid');

  Shavaluator = require('shavaluator');

  luaCommands = require('./redis_lua');

  defaultConfig = {
    lifetime: 1000,
    retryTimeout: 5,
    maxRetries: 0
  };

  module.exports = function(opts) {
    var config;

    config = _.extend({}, defaultConfig, opts);
    return function() {
      var args, attemptAcquire, callback, delequal_args, key, lockOpts, lockValue, retries, setnx_pexpire_args, shavaluator;

      key = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      switch (args.length) {
        case 1:
          lockOpts = config;
          callback = args[0];
          break;
        case 2:
          lockOpts = _.extend({}, config, args[0]);
          callback = args[1];
          break;
        default:
          throw 'Invalid number of arguments to lock function';
      }
      retries = 0;
      lockValue = uuid.v1();
      setnx_pexpire_args = {
        keys: key,
        args: [lockValue, lockOpts.lifetime]
      };
      delequal_args = {
        keys: key,
        args: lockValue
      };
      shavaluator = new Shavaluator();
      shavaluator.add(luaCommands);
      shavaluator.redis = lockOpts.redis;
      attemptAcquire = function() {
        return shavaluator.setnx_pexpire(setnx_pexpire_args, function(err, result) {
          if (err) {
            return callback(err, retries);
          } else if (result === 0) {
            if (retries >= lockOpts.maxRetries) {
              return callback(new Error('Exceeded max retry count'), retries);
            } else {
              retries += 1;
              return setTimeout(attemptAcquire, lockOpts.retryTimeout);
            }
          } else {
            return callback(null, retries, function(unlockCallback) {
              return shavaluator.delequal(delequal_args, function(err, result) {
                if (unlockCallback) {
                  return unlockCallback(err, result === 1);
                }
              });
            });
          }
        });
      };
      return attemptAcquire();
    };
  };

}).call(this);
