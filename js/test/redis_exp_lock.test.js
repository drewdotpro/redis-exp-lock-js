// Generated by CoffeeScript 1.6.2
(function() {
  var redisClient, redisExpLock, should, testHelper, withLock;

  testHelper = require('./test_helper');

  should = require('should');

  redisExpLock = require('../lib/redis_exp_lock');

  redisClient = testHelper.getRedisClient();

  withLock = redisExpLock({
    redis: redisClient
  });

  describe('redisExpLock', function() {
    beforeEach(function(done) {
      return redisClient.flushdb(done);
    });
    describe('when the lock has already been acquired', function() {
      beforeEach(function() {
        return withLock('testLock', function(err, retries, critSecDone) {});
      });
      it('should prevent other clients from acquiring the lock', function(done) {
        return withLock('testLock', function(err, retries, critSecDone) {
          should.exist(err);
          return done();
        });
      });
      return it('the retry count should equal the maximum number of retries', function(done) {
        var retries;

        retries = 5;
        return withLock('testLock', {
          maxRetries: retries
        }, function(err, retries, critSecDone) {
          should.exist(err);
          retries.should.eql(retries);
          return done();
        });
      });
    });
    it('should allow other clients to acquire the lock after a release', function(done) {
      return withLock('testLock', function(err, retries, critSecDone) {
        if (!err) {
          return critSecDone(function(err, result) {
            if (!err) {
              return withLock('testLock', function(err, retries, critSecDone) {
                if (!err) {
                  should.not.exist(err);
                  retries.should.eql(0);
                  return done();
                }
              });
            }
          });
        }
      });
    });
    return describe('expiration cases', function() {
      var firstLockLifetime;

      firstLockLifetime = 50;
      beforeEach(function() {
        return withLock('testLock', {
          lifetime: firstLockLifetime
        }, function(err, retries, critSecDone) {});
      });
      it('should acquire the lock if the lifetime has elapsed', function(done) {
        return setTimeout(function() {
          return withLock('testLock', function(err, retries, critSecDone) {
            should.not.exist(err);
            retries.should.eql(0);
            return done();
          });
        }, firstLockLifetime + 10);
      });
      return it('should resolve lock contention with only a single winner', function(done) {
        var contenders, failures, finished, i, lockOpts, retryTimeout, successes, _i, _results;

        contenders = 10;
        successes = 0;
        failures = 0;
        finished = 0;
        retryTimeout = 5;
        lockOpts = {
          retryTimeout: retryTimeout,
          maxRetries: (firstLockLifetime / retryTimeout) + 2
        };
        _results = [];
        for (i = _i = 0; _i < contenders; i = _i += 1) {
          _results.push(withLock('testLock', lockOpts, function(err, retries, critSecDone) {
            if (err) {
              failures += 1;
              retries.should.eql(lockOpts.maxRetries);
            } else {
              successes += 1;
              (retries > 0).should.be["true"];
            }
            finished += 1;
            if (finished === contenders) {
              successes.should === 1;
              failures.should === contenders - 1;
              return done();
            }
          }));
        }
        return _results;
      });
    });
  });

}).call(this);
